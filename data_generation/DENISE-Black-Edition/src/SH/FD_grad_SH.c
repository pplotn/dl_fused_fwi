/*
 * FD-based FWI gradient computation (2D SH problem)  
 *
 * Daniel Koehn
 * Kiel, 20/10/2018
 */

#include "fd.h"

void FD_grad_SH(){

/* global variables */
/* ---------------- */

/* forward modelling */
extern int MYID, FDORDER, NX, NY, NT, L, READMOD, QUELLART, QUELLTYP, RUN_MULTIPLE_SHOTS, TIME_FILT, READREC;
extern int LOG, SEISMO, N_STREAMER, FW, NXG, NYG, IENDX, IENDY, NTDTINV, IDXI, IDYI, NXNYI, INV_STF, DTINV;
extern float FC_SPIKE_1, FC_SPIKE_2, FC, FC_START, TIME, DT;
extern char LOG_FILE[STRING_SIZE], MFILE[STRING_SIZE];
extern FILE *FP;

/* gravity modelling/inversion */
extern int GRAVITY, NZGRAV, NGRAVB, GRAV_TYPE, BACK_DENSITY;
extern char GRAV_DATA_OUT[STRING_SIZE], GRAV_DATA_IN[STRING_SIZE], GRAV_STAT_POS[STRING_SIZE], DFILE[STRING_SIZE];
extern float LAM_GRAV, GAMMA_GRAV, LAM_GRAV_GRAD;

/* full waveform inversion */
extern int GRAD_METHOD, NLBFGS, ITERMAX, IDX, IDY, INVMAT1, EPRECOND, PCG_BETA;
extern int GRAD_FORM, POS[3], QUELLTYPB, MIN_ITER, MODEL_FILTER, INV_MOD_OUT;
extern float FC_END, PRO, C_vs, C_rho, C_taus, EPS_SCALE;
extern char MISFIT_LOG_FILE[STRING_SIZE], JACOBIAN[STRING_SIZE];
extern char *FILEINP1;

/* local variables */
int ns, nseismograms=0, nt, nd, fdo3, j, i, iter, h, hin, iter_true, SHOTINC, s=0, imod, jmod, jj, ii, count_mod;
int buffsize, ntr=0, ntr_loc=0, ntr_glob=0, nsrc=0, nsrc_loc=0, nsrc_glob=0, ishot, nshots=0, itestshot, IDXMOD, IDYMOD;
int FD_GRAD_MAT;

float sum, eps_scale, opteps_vp, opteps_vs, opteps_rho, opteps_ts, Vs_max, rho_max, taus_max, Vs_sum, rho_sum, taus_sum, deltam;
char *buff_addr, ext[10], *fileinp, source_signal_file[STRING_SIZE];

double time1, time2, time7, time8, time_av_v_update=0.0, time_av_s_update=0.0, time_av_v_exchange=0.0; 
double time_av_s_exchange=0.0, time_av_timestep=0.0;
	
float L2sum, L2, L2_init;
	
float ** taper_coeff, * epst1, *hc=NULL;
int * DTINV_help;

MPI_Request *req_send, *req_rec;
MPI_Status  *send_statuses, *rec_statuses;

/* Variables for step length calculation */
int step1, step3=0;
float eps_true, tmp;

/* Variables for the L-BFGS method */
float * rho_LBFGS, * alpha_LBFGS, * beta_LBFGS; 
float * y_LBFGS, * s_LBFGS, * q_LBFGS, * r_LBFGS;
int NLBFGS_class, LBFGS_pointer, NLBFGS_vec;

/* Variables for PCG */
float * PCG_old, * PCG_new, * PCG_dir;
int PCG_class, PCG_vec;

/* Variables for energy weighted gradient */
float ** Ws, **Wr, **We;

/* parameters for FWI-workflow */
int stagemax=0, nstage;

/*vector for abort criterion*/
float * L2_hist=NULL;

/* help variable for MIN_ITER */
int min_iter_help=0;

/* parameters for gravity inversion */
float * gz_mod, * gz_res;
float ** gravpos=NULL, ** rho_grav=NULL, ** rho_grav_ext=NULL;
float ** grad_grav=NULL;
int ngrav=0, nxgrav, nygrav;
float L2_grav, FWImax, GRAVmax, FWImax_all, GRAVmax_all ;
char jac[STRING_SIZE];

FILE *FPL2, *FP_stage, *FP_GRAV, *LAMBDA, *FP_GRAD;

if (MYID == 0){
   time1=MPI_Wtime(); 
   clock();
}

/* open log-file (each PE is using different file) */
/*	fp=stdout; */
sprintf(ext,".%i",MYID);  
strcat(LOG_FILE,ext);

if ((MYID==0) && (LOG==1)) FP=stdout;
else FP=fopen(LOG_FILE,"w");
fprintf(FP," This is the log-file generated by PE %d \n\n",MYID);

/* ----------------------- */
/* define FD grid geometry */
/* ----------------------- */

/* domain decomposition */
initproc();

NT=iround(TIME/DT); /* number of timesteps */

/* output of parameters to log-file or stdout */
if (MYID==0) write_par(FP);

/* NXG, NYG denote size of the entire (global) grid */
NXG=NX;
NYG=NY;

/* In the following, NX and NY denote size of the local grid ! */
NX = IENDX;
NY = IENDY;

NTDTINV=ceil((float)NT/(float)DTINV);		/* round towards next higher integer value */

/* save every IDXI and IDYI spatial point during the forward modelling */
IDXI=1;
IDYI=1;

NXNYI=(NX/IDXI)*(NY/IDYI);
SHOTINC=1;

/* use only every DTINV time sample for the inversion */
DTINV_help=ivector(1,NT);

/* read parameters from workflow-file (stdin) */
FP_stage=fopen(FILEINP1,"r");
if(FP_stage==NULL) {
	if (MYID == 0){
		printf("\n==================================================================\n");
		printf(" Cannot open Denise workflow input file %s \n",FILEINP1);
		printf("\n==================================================================\n\n");
		err(" --- ");
	}
}

/* estimate number of lines in FWI-workflow */
i=0;
stagemax=0;
while ((i=fgetc(FP_stage)) != EOF)
if (i=='\n') ++stagemax;
rewind(FP_stage);
stagemax--;
fclose(FP_stage);

/* define data structures for PSV problem */
struct waveSH;
struct waveSH_PML;
struct matSH;
struct fwiSH;
struct mpiPSV;
struct seisSH;
struct seisSHfwi;
struct acq;

nd = FDORDER/2 + 1;
fdo3 = 2*nd;
buffsize=2.0*2.0*fdo3*(NX +NY)*sizeof(MPI_FLOAT);

/* allocate buffer for buffering messages */
buff_addr=malloc(buffsize);
if (!buff_addr) err("allocation failure for buffer for MPI_Bsend !");
MPI_Buffer_attach(buff_addr,buffsize);

/* allocation for request and status arrays */
req_send=(MPI_Request *)malloc(REQUEST_COUNT*sizeof(MPI_Request));
req_rec=(MPI_Request *)malloc(REQUEST_COUNT*sizeof(MPI_Request));
send_statuses=(MPI_Status *)malloc(REQUEST_COUNT*sizeof(MPI_Status));
rec_statuses=(MPI_Status *)malloc(REQUEST_COUNT*sizeof(MPI_Status));

/* --------- add different modules here ------------------------ */
ns=NT;	/* in a FWI one has to keep all samples of the forward modeled data
	at the receiver positions to calculate the adjoint sources and to do 
	the backpropagation; look at function saveseis_glob.c to see that every
	NDT sample for the forward modeled wavefield is written to su files*/

if (SEISMO && (READREC!=2)){

   acq.recpos=receiver(FP, &ntr, ishot);
   acq.recswitch = ivector(1,ntr);
   acq.recpos_loc = splitrec(acq.recpos,&ntr_loc, ntr, acq.recswitch);
   ntr_glob=ntr;
   ntr=ntr_loc;
   
}

if(READREC!=2){

   /* Memory for seismic data */
   alloc_seisSH(ntr,ns,&seisSH);

   /* Memory for FWI seismic data */ 
   alloc_seisSHfwi(ntr,ntr_glob,ns,&seisSHfwi);
   
   /* Memory for full data seismograms */
   alloc_seisSHfull(&seisSH,ntr_glob);

}

/* memory allocation for abort criterion*/
L2_hist = vector(1,1000);

/* estimate memory requirement of the variables in megabytes*/
	
switch (SEISMO){
case 1 : /* particle velocities only */
	nseismograms=1;	
	break;	
}		

/* calculate memory requirements for PSV forward problem */
mem_fwiPSV(nseismograms,ntr,ns,fdo3,nd,buffsize,ntr_glob);

/* Define gradient formulation */
/* GRAD_FORM = 2 - stress-velocity gradients for symmetrized impedance matrix */
GRAD_FORM = 2;

/* Calculate FD-based gradient for model parameter class FD_GRAD_MAT */
/* FD_GRAD_MAT = 1 - S-wave velocity */
/* FD_GRAD_MAT = 2 - density */
/* FD_GRAD_MAT = 3 - tau_s = 2/Qs */
FD_GRAD_MAT = 2;

/* allocate memory for SH forward problem */
alloc_SH(&waveSH,&waveSH_PML);

/* calculate damping coefficients for CPMLs (SH problem)*/
if(FW>0){PML_pro(waveSH_PML.d_x, waveSH_PML.K_x, waveSH_PML.alpha_prime_x, waveSH_PML.a_x, waveSH_PML.b_x, waveSH_PML.d_x_half, waveSH_PML.K_x_half, waveSH_PML.alpha_prime_x_half, waveSH_PML.a_x_half, 
                 waveSH_PML.b_x_half, waveSH_PML.d_y, waveSH_PML.K_y, waveSH_PML.alpha_prime_y, waveSH_PML.a_y, waveSH_PML.b_y, waveSH_PML.d_y_half, waveSH_PML.K_y_half, waveSH_PML.alpha_prime_y_half, 
                 waveSH_PML.a_y_half, waveSH_PML.b_y_half);
}

/* allocate memory for SH material parameters */
alloc_matSH(&matSH);

/* allocate memory for SH FWI parameters */
alloc_fwiSH(&fwiSH);

/* allocate memory for PSV MPI variables */
alloc_mpiPSV(&mpiPSV);

taper_coeff=  matrix(1,NY,1,NX);

/* memory for source position definition */
acq.srcpos1=fmatrix(1,8,1,1);

/* memory of L2 norm */
epst1 = vector(1,3);
	
fprintf(FP," ... memory allocation for PE %d was successfull.\n\n", MYID);

/* Holberg coefficients for FD operators*/
hc = holbergcoeff();

MPI_Barrier(MPI_COMM_WORLD);

/* Reading source positions from SOURCE_FILE */ 	
acq.srcpos=sources(&nsrc);
nsrc_glob=nsrc;

/* create model grids */
if(L){
	if (READMOD) readmod_visc_SH(matSH.prho,matSH.pu,matSH.ptaus,matSH.peta);
		/*else model(matPSV.prho,matPSV.ppi,matPSV.pu,matPSV.ptaus,matPSV.ptaup,matPSV.peta);*/
} else{
	if (READMOD) readmod_elastic_SH(matSH.prho,matSH.pu);
    		/*else model_elastic(matPSV.prho,matPSV.ppi,matPSV.pu);*/
}

/* check if the FD run will be stable and free of numerical dispersion */
if(L){	
	checkfd_visc_SH(FP,matSH.prho,matSH.pu,matSH.ptaus,matSH.peta,hc);
} else{
	checkfd_elast_SH(FP,matSH.prho,matSH.pu,hc);
}
      
SHOTINC=1;
    
iter_true=1;
/* Begin of FWI-workflow */
for(nstage=1;nstage<=1;nstage++){

/* read workflow input file *.inp */
FP_stage=fopen(FILEINP1,"r");
read_par_inv(FP_stage,nstage,stagemax);
/*fclose(FP_stage);*/

FC=FC_END;

iter=1;

if (MYID==0)
   {
   time2=MPI_Wtime();
   fprintf(FP,"\n\n\n ------------------------------------------------------------------\n");
   fprintf(FP,"\n\n\n                   Estimate FD-based FWI gradient");
   fprintf(FP,"\n\n\n ------------------------------------------------------------------\n");
   }

/* For the calculation of the material parameters between gridpoints
   they have to be averaged. For this, values lying at 0 and NX+1,
   for example, are required on the local grid. These are now copied from the
   neighbouring grids */
if (L){
	matcopy_SH(matSH.prho,matSH.pu,matSH.ptaus);
} else{
	matcopy_elastic_SH(matSH.prho,matSH.pu);
}

MPI_Barrier(MPI_COMM_WORLD);

av_mu_SH(matSH.pu, matSH.puip, matSH.pujp, matSH.prho);
inv_rho_SH(matSH.prho, matSH.prhoi);
if (L) av_tau(matSH.ptaus,matSH.ptausipjp);

/* Preparing memory variables for update_s (viscoelastic) */
if (L) prepare_update_s_visc_SH(matSH.etajm, matSH.etaip, matSH.peta, matSH.fipjp, matSH.pujp, matSH.puip, 
				matSH.prho, matSH.ptaus, matSH.ptausipjp, matSH.f, matSH.g, matSH.bip, matSH.bjm, 
				matSH.cip, matSH.cjm, matSH.dip, matSH.d, matSH.e); 


    for (i=1;i<=NX;i=i+IDX){ 
	for (j=1;j<=NY;j=j+IDY){
	
	if(INVMAT1==1){
	
	  fwiSH.Vs0[j][i] = matSH.pu[j][i];
	  fwiSH.Rho0[j][i] = matSH.prho[j][i];
	  fwiSH.Taus0[j][i] = matSH.ptaus[j][i];

        }
	                   		 
	if(INVMAT1==2){
        
	  fwiSH.Vs0[j][i] = sqrt(matSH.pu[j][i]*matSH.prho[j][i]);
	  fwiSH.Rho0[j][i] = matSH.prho[j][i];
	  fwiSH.Taus0[j][i] = matSH.ptaus[j][i];
	
	}
	 
	if(INVMAT1==3){
        
	  fwiSH.Vs0[j][i] = matSH.pu[j][i];
	  fwiSH.Rho0[j][i] = matSH.prho[j][i];
	  fwiSH.Taus0[j][i] = matSH.ptaus[j][i];
	
	}  
	
    }
    }

/* ---------------------------------- */
/* calculate maximum model parameters */
/* ---------------------------------- */

	Vs_max = 0.0;
	rho_max = 0.0;
	taus_max = 0.0;
	 
        for (i=1;i<=NX;i=i+IDX){
           for (j=1;j<=NY;j=j+IDY){
	  
		 /* calculate maximum Vs */
		 if(matSH.pu[j][i] > Vs_max){
		     Vs_max = matSH.pu[j][i];
		 }
		 
		 /* calculate maximum rho */
		 if(matSH.prho[j][i] > rho_max){
		     rho_max = matSH.prho[j][i];
		 }

		 /* calculate maximum taus */
		 if(matSH.ptaus[j][i] > taus_max){
		     taus_max = matSH.ptaus[j][i];
		 }
	
           }
        }
		
        /* calculate maximum Vs, rho and taus of all CPUs*/
	
	Vs_sum = 0.0;
        MPI_Allreduce(&Vs_max,&Vs_sum,1,MPI_FLOAT,MPI_MAX,MPI_COMM_WORLD);
        Vs_max=Vs_sum;
	
	rho_sum = 0.0;
        MPI_Allreduce(&rho_max,&rho_sum,1,MPI_FLOAT,MPI_MAX,MPI_COMM_WORLD);
        rho_max=rho_sum;

	taus_sum = 0.0;
        MPI_Allreduce(&taus_max,&taus_sum,1,MPI_FLOAT,MPI_MAX,MPI_COMM_WORLD);
        taus_max=taus_sum;
		
	if(MYID==0){
           printf("Vs_max = %e \t rho_max = %e \t taus_max = %e \n ",Vs_max, rho_max, taus_max);	
	}

if(INV_STF){

	if (RUN_MULTIPLE_SHOTS) nshots=nsrc; else nshots=1;

	for (ishot=1;ishot<=nshots;ishot+=1){			  

	    for (nt=1;nt<=8;nt++) acq.srcpos1[nt][1]=acq.srcpos[nt][ishot]; 

	    /* set QUELLTYP for each shot */
            QUELLTYP = acq.srcpos[8][ishot];

		if (RUN_MULTIPLE_SHOTS){

		        /* find this single source positions on subdomains */
		        if (nsrc_loc>0) free_matrix(acq.srcpos_loc,1,8,1,1);
		        acq.srcpos_loc=splitsrc(acq.srcpos1,&nsrc_loc, 1);
		}


		else{
		        /* Distribute multiple source positions on subdomains */
		        acq.srcpos_loc = splitsrc(acq.srcpos,&nsrc_loc, nsrc);
		}

	    MPI_Barrier(MPI_COMM_WORLD);

	    /*==================================================================================
		            Estimate source time function by Wiener deconvolution
	    ==================================================================================*/

	    if((INV_STF)&&(iter==1)){
	        stf_sh(&waveSH,&waveSH_PML,&matSH,&fwiSH,&mpiPSV,&seisSH,&seisSHfwi,&acq,hc,ishot,nshots,nsrc_loc,nsrc,ns,ntr,ntr_glob,iter,Ws,Wr,hin,DTINV_help,req_send,req_rec);
	    }

        }
}


/* ===========================================================================================================================================*/
/* =============================================== Evaluate objective function for initial model==============================================*/
/* ===========================================================================================================================================*/

seisSHfwi.L2 = obj_sh(&waveSH,&waveSH_PML,&matSH,&fwiSH,&mpiPSV,&seisSH,&seisSHfwi,&acq,hc,nsrc,nsrc_loc,nsrc_glob,ntr,ntr_glob,ns,1,1,Ws,Wr,hin,DTINV_help,EPS_SCALE,req_send,req_rec);
L2_init = seisSHfwi.L2;

printf("L2 = %e \t L2_init = %e \n", L2, L2_init);

/* ===========================================================================================================================================*/
/* ==================== Evaluate objective function after perturbation of individual model parameters on FD grid =============================*/
/* ===========================================================================================================================================*/

/* loop over FD grid points */
count_mod = 1;
IDXMOD=1;
IDYMOD=1;
for (imod=1;imod<=NXG;imod=imod+IDXMOD){
    for (jmod=1;jmod<=NYG;jmod=jmod+IDYMOD){

	if(MYID==0){printf("Evaluate FD-based gradient for model parameter %d \t of %d \n",count_mod,NXG*NYG);}

	/* Perturbate model parameter on the global grid in the correct sub-domain */
	if ((POS[1]==((imod-1)/NX)) && (POS[2]==((jmod-1)/NY))){
	   ii=imod-POS[1]*NX;
	   jj=jmod-POS[2]*NY;	   	  

	   if(FD_GRAD_MAT==1){
	      deltam = EPS_SCALE * fwiSH.Vs0[jj][ii];
	      matSH.pu[jj][ii] = matSH.pu[jj][ii] - deltam;
	   } 	
	   
	   if(FD_GRAD_MAT==2){
	      deltam = EPS_SCALE * fwiSH.Rho0[jj][ii];
	      matSH.prho[jj][ii] = matSH.prho[jj][ii] - deltam;
	   }

	   if(FD_GRAD_MAT==3){
	      deltam = EPS_SCALE * fwiSH.Taus0[jj][ii];
	      matSH.ptaus[jj][ii] = matSH.ptaus[jj][ii] - deltam;
	   }
	   	   
        }

	seisSHfwi.L2 = obj_sh(&waveSH,&waveSH_PML,&matSH,&fwiSH,&mpiPSV,&seisSH,&seisSHfwi,&acq,hc,nsrc,nsrc_loc,nsrc_glob,ntr,ntr_glob,ns,1,1,Ws,Wr,hin,DTINV_help,EPS_SCALE,req_send,req_rec);
	L2 = seisSHfwi.L2;

	/* Evaluate FD-based gradient and unperturbate model parameter */
	if ((POS[1]==((imod-1)/NX)) && (POS[2]==((jmod-1)/NY))){
	   ii=imod-POS[1]*NX;
	   jj=jmod-POS[2]*NY;

	   if(FD_GRAD_MAT==1){
	      fwiSH.waveconv_u[jj][ii] = (L2 - L2_init) / deltam;
	      matSH.pu[jj][ii] = matSH.pu[jj][ii] + deltam;
	   }

	   if(FD_GRAD_MAT==2){
	      fwiSH.waveconv_rho[jj][ii] = (L2 - L2_init) / deltam;
	      matSH.prho[jj][ii] = matSH.prho[jj][ii] + deltam;
	   }
	   
	   if(FD_GRAD_MAT==3){
	      fwiSH.waveconv_ts[jj][ii] = (L2 - L2_init) / deltam;
	      matSH.ptaus[jj][ii] = matSH.ptaus[jj][ii] + deltam;
	   }
	   
        }

        count_mod++;

    }
}

/* FD-based gradient */
if(FD_GRAD_MAT==1){sprintf(jac,"%s_FD_vs.old.%i.%i",JACOBIAN,POS[1],POS[2]);}
if(FD_GRAD_MAT==2){sprintf(jac,"%s_FD_rho.old.%i.%i",JACOBIAN,POS[1],POS[2]);}
if(FD_GRAD_MAT==3){sprintf(jac,"%s_FD_ts.old.%i.%i",JACOBIAN,POS[1],POS[2]);}

FP_GRAD=fopen(jac,"wb");

for (i=1;i<=NX;i=i+IDX){   
   for (j=1;j<=NY;j=j+IDY){
      if(FD_GRAD_MAT==1){tmp = fwiSH.waveconv_u[j][i];}
      if(FD_GRAD_MAT==2){tmp = fwiSH.waveconv_rho[j][i];}  
      if(FD_GRAD_MAT==3){tmp = fwiSH.waveconv_ts[j][i];}
      fwrite(&tmp,sizeof(float),1,FP_GRAD);
   }
}
        
fclose(FP_GRAD);

MPI_Barrier(MPI_COMM_WORLD);
        
/* merge gradient file */ 
if(FD_GRAD_MAT==1){sprintf(jac,"%s_FD_vs.old",JACOBIAN);}
if(FD_GRAD_MAT==2){sprintf(jac,"%s_FD_rho.old",JACOBIAN);}
if(FD_GRAD_MAT==3){sprintf(jac,"%s_FD_ts.old",JACOBIAN);}
if (MYID==0) mergemod(jac,3);

} /* End of FWI-workflow loop */

/* deallocate memory for SH forward problem */
dealloc_SH(&waveSH,&waveSH_PML);
 
 /* free memory for viscoelastic modeling variables */
 if (L) {
		free_matrix(matSH.ptaus,-nd+1,NY+nd,-nd+1,NX+nd);
		free_matrix(matSH.ptausipjp,-nd+1,NY+nd,-nd+1,NX+nd);
		free_vector(matSH.peta,1,L);
		free_vector(matSH.etaip,1,L);
		free_vector(matSH.etajm,1,L);
		free_vector(matSH.bip,1,L);
		free_vector(matSH.bjm,1,L);
		free_vector(matSH.cip,1,L);
		free_vector(matSH.cjm,1,L);
		free_matrix(matSH.f,-nd+1,NY+nd,-nd+1,NX+nd);
		free_matrix(matSH.fipjp,-nd+1,NY+nd,-nd+1,NX+nd);
		free_matrix(matSH.g,-nd+1,NY+nd,-nd+1,NX+nd);
		free_f3tensor(matSH.dip,-nd+1,NY+nd,-nd+1,NX+nd,1,L);
		free_f3tensor(matSH.d,-nd+1,NY+nd,-nd+1,NX+nd,1,L);
		free_f3tensor(matSH.e,-nd+1,NY+nd,-nd+1,NX+nd,1,L);
}
 
/* de-allocate buffer for messages */
MPI_Buffer_detach(buff_addr,&buffsize);

MPI_Barrier(MPI_COMM_WORLD);

if (MYID==0){
	fprintf(FP,"\n **Info from main (written by PE %d): \n",MYID);
	fprintf(FP," CPU time of program per PE: %li seconds.\n",clock()/CLOCKS_PER_SEC);
	time8=MPI_Wtime();
	fprintf(FP," Total real time of program: %4.2f seconds.\n",time8-time1);
	time_av_v_update=time_av_v_update/(double)NT;
	time_av_s_update=time_av_s_update/(double)NT;
	time_av_v_exchange=time_av_v_exchange/(double)NT;
	time_av_s_exchange=time_av_s_exchange/(double)NT;
	time_av_timestep=time_av_timestep/(double)NT;
	/* fprintf(FP," Average times for \n");
	fprintf(FP," velocity update:  \t %5.3f seconds  \n",time_av_v_update);
	fprintf(FP," stress update:  \t %5.3f seconds  \n",time_av_s_update);
	fprintf(FP," velocity exchange:  \t %5.3f seconds  \n",time_av_v_exchange);
	fprintf(FP," stress exchange:  \t %5.3f seconds  \n",time_av_s_exchange);
	fprintf(FP," timestep:  \t %5.3f seconds  \n",time_av_timestep);*/
		
}


}



